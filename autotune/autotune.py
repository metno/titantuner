#!.venv/bin/python3

import titanlib
import random
from typing import Callable, Union, Tuple, Sequence
import numpy as np
import sys
import math
import matplotlib.pyplot as plt
import scipy.optimize as opt

print('titanlib version:', titanlib.version())
print('----')

# from functools import reduce

# typedefs
numeric = Union[int, float]

# constants
m = 0.5


def gen_errors(
    values: np.ndarray, num_errors: int, gen_func: Callable[[], int]
) -> np.ndarray:
    '''Create an array containing errors generated by the gen_fun function.
    This array has the same length as the value array (initial data array).
    The number of generated error is given by num_error.
    The indexes of the array for which values gets an error are randomly generated.
    If values[i] should stay unchanged, errors[i] is set to 0.
    Note: in this function only the length of the value array is used, not the values themselves
    '''
    error_indices = random.sample(
        range(len(values)), num_errors
    )

    errors = np.zeros(len(values))

    for i in error_indices:
        errors[i] = gen_func()

    return errors


def seed_errors(
    values: np.ndarray,
    errors: np.ndarray,
    errorfunc: Callable[[int, numeric], numeric],
) -> np.ndarray:
    '''Apply the errorfunc function to elements of the values array using the errors array as 
    argument. If the error is null, no error is applied'''
    for i in range(len(values)):
        if errors[i] != 0:
            values[i] = errorfunc(errors[i], values[i])

    return values  # TODO test whether numpy modifies in place


def calc_hit_FR_rates(results: np.ndarray, errors: np.ndarray) -> Tuple[float, float]:
    '''Compute and return the hit rate and false alarm rate'''
    hits = 0
    FAs = 0

    perturbed = 0
    unperturbed = 0

    for i in range(len(results)):
        if errors[i] == 0:
            unperturbed += 1
            if results[i] != 0:
                FAs += 1

        if errors[i] != 0:
            perturbed += 1
            if results[i] != 0:
                hits += 1

    # defaults in case of divide by zero
    hit_rate = 1
    false_alarm_rate = 0

    if perturbed != 0:
        hit_rate = hits / perturbed
    if unperturbed != 0:
        false_alarm_rate = FAs / unperturbed

    return hit_rate, false_alarm_rate


def cost_function(hit_rate: float, false_alarm_rate: float, m: float) -> float:
    '''Compute a cost. m is c(FA)P(G)/[c(M)P(notG)].
    c(FA) is the cost of a false alarm, c(M) cost of miss,
    P(G) probability of having a gross error, notG the negation of G.
    For instance P(G)=0.1-15% for traditional stations, 
                 P(G)=20% for crowdsourced obs.
    '''
    return 1 - hit_rate + (m * false_alarm_rate)


def read_QCed_netatmo_data(filename: str) -> Tuple[titanlib.Points, np.ndarray]:
    '''Reads netatmo file called filename.
     Keeps only Netatmo data (prid == 3) that are OK (qcflag == 0)
    '''
    lats = []
    lons = []
    elevs = []
    values = []

    with open(filename) as f:
        next(f)  # skip first line (titles)
        for line in f:
            fields = line.split(";")

            prid = int(fields[4])
            qcflag = int(fields[5])
            # Note: in case other providers should be selected :
            # prid is defined as this 
            # 1:"WMO", 2: "Non-WMO", 3: "Netatmo", 4: "Foreign", 5: "SVV", 6:"Bergen", 
            # 7:"FMI", 100: "Radar"}
            # defined in yrop/yrprod/bin/titan_stats.py
            if prid == 3 and qcflag == 0:
                lats.append(float(fields[0]))
                lons.append(float(fields[1]))
                elevs.append(float(fields[2]))
                values.append(float(fields[3]))

    return titanlib.Points(lats, lons, elevs), values


def precipitation_errorfunc(error: int, value: float) -> float:
    '''Blocked gauge/Leaking water
       Define a rule about how the precipitation value should be modified to 
       an erroneous value, if error is not null.
       If precipitation exists, set the precipitation to 0 (blocked gauge)
       If no precipitation exists, set the precipitation to 1 (leaking water)'''
    if error != 0:
        if value != 0:
            return 0
        else:
            return 1
    return value


def temperature_errorfunc(error: int, value: float) -> float:
    '''Define a rule about how the precipitation value should be modified to 
       an erroneous value, if error is not null.
       Add the error value to the initial value'''
    if error != 0:
        return value + error
    return value

def gen_error_temperature() -> int:
    '''Define a random error (difference) for the temperature
       with several possible predeterminated values'''
    return random.choice([-5, -3, -2, -1, 1, 2, 3, 5])


#### Plots to understand the effect of the threshold
def plot_iso_performance_lines(ax, m):
    '''add isoperformamce lines of slope m'''
    for i in [x / 10.0 for x in range(-math.ceil(m) * 10, 10, 1)]:
        ax.plot([0, 1], [i, m + i], linestyle="dashed", color="gray")
    return ax

def make_h_far_plot(
    hit_rates: np.ndarray,
    false_alarm_rates: np.ndarray,
    thresholds: np.ndarray,
):
    ''' plot of 
    1) the false alarm rate on the x-axis, versus the hit-rate
      on the y-axis (ROC curve) 
    2) Hit rate = False alarm rate line
    3) isoperformance lines
      Save figure as hfar.png'''
    fig, ax = plt.subplots()
    ax.plot(false_alarm_rates, hit_rates)

    for i in range(len(hit_rates)):
        ax.text(false_alarm_rates[i], hit_rates[i], str(thresholds[i]) + "Ïƒ")

    ax.plot([0, 1], [0, 1], linestyle="dotted", color="gray")
    ax = plot_iso_performance_lines(ax, m)

    plt.xlim(0, 1)
    plt.ylim(0, 1)

    ax.set_xlabel("False alarm rate")
    ax.set_ylabel("Hit rate")

    fig.show()
    fig.savefig("hfar.png", dpi=300)


def make_threshold_cost_plot(thresholds: np.ndarray, costs: np.ndarray):
    '''Plot the cost as a function of the threshold
    Save figure as cost_threshold.png'''
    fig, ax = plt.subplots()
    ax.plot(thresholds, costs)

    ax.set_xlabel("Threshold (in standard deviations)")
    ax.set_ylabel("Cost")

    fig.show()
    fig.savefig("cost_threshold.png", dpi=300)


def make_charts():
    ''' Using other parameters as constants, study how the buddy_check test
      is sensitive to the threshold (variance threshold for flagging a station).
      Data are temperature observations contained in the file
      whose name is given as first argument.'''
    # test data:
    # locations = titanlib.Points([60, 60.1, 60.2], [10, 10, 10], [0, 0, 0])
    # values = [0, 1, 1]
    filename = sys.argv[1]
    locations, values = read_QCed_netatmo_data(filename)
    num_error = len(values) // 10
    print('number of observations:', len(values) )
    print('number of generated errors:', num_error)
    print("---")
    if(len(values)==0):
        print("WARNING, No valid observation. Autotune.py can't make charts.")
        return(0)
    
    errors = gen_errors(values, num_error, gen_error_temperature)
    seeded_values = seed_errors(values, errors, temperature_errorfunc)

    # print("seeded_values: ", seeded_values)

    hit_rates = []
    false_alarm_rates = []
    costs = []
    thresholds = [x / 10.0 for x in range(5, 50, 5)]
    for threshold in thresholds:
        print("-- TESTING WITH threshold: ", threshold, " --")
        results = titanlib.buddy_check(
            locations,
            seeded_values,
            np.full(locations.size(), 10000), # radius
            np.full(locations.size(), 3), # number min of stations
            threshold,
            200, # max elev diff
            0, #elev gradient
            1, # minimum standard deviation
            3, # number of iterations
        )

        # print("results: ", results)
        # print("flag_count: ", reduce(lambda x, y: x + y, results))

        hit_rate, false_alarm_rate = calc_hit_FR_rates(results, errors)

        cost = cost_function(hit_rate, false_alarm_rate, m)

        hit_rates.append(hit_rate)
        false_alarm_rates.append(false_alarm_rate)
        costs.append(cost)

        print(f'cost: {cost:.5f}, hit rate: {hit_rate:.5f}, false alarm rate: {false_alarm_rate:.5f}')
        print("---")
    make_h_far_plot(hit_rates, false_alarm_rates, thresholds)
    make_threshold_cost_plot(thresholds, costs)


def gen_optimiseable(
    locations: titanlib.Points,
    errors: np.ndarray,
    seeded_values: np.ndarray,
) -> Callable[[Sequence[float]], float]:
    '''define and return the cost function to be optimized
    in order to find which radius, minimal number of stations
    and variance threshold are best to use the buddy check test.
    The other parameters for the buddy check are taken as constants'''

    def optimiseable(params: Sequence[float]) -> float:
        results = titanlib.buddy_check(
            locations,
            seeded_values,
            np.full(locations.size(), params[0]), # radius
            np.full(locations.size(), params[1]), # number min of stations
            params[2], # variance threshold
            200, # max elev diff
            0, # elev gradient
            1,  # minimum standard deviation
            3, # number of iterations
        )

        hit_rate, false_alarm_rate = calc_hit_FR_rates(results, errors)

        cost = cost_function(hit_rate, false_alarm_rate, m)
        print("params:", params)
        print(f'cost: {cost:.5f}, hit rate: {hit_rate:.5f}, false alarm rate: {false_alarm_rate:.5f}')
        print("---")
        return cost

    return optimiseable


def minimise_cost():
    ''' Do an optimization study to find out which parameters are
    best for a given test. Data are temperature observations contained 
    in the file whose name is given as first argument. Buddy check is
    the default test to be optimized'''
    filename = sys.argv[1]
    locations, values = read_QCed_netatmo_data(filename)
    num_error = len(values) // 10
    print('number of observations:', len(values))
    print('number of generated errors:', num_error)
    print("---")
    if(len(values)==0):
        print("WARNING, No valid observation. Autotune.py can't give optimized parameters.")
        return(0)
    errors = gen_errors(values, num_error, gen_error_temperature)
    seeded_values = seed_errors(values, errors, temperature_errorfunc)

    optimiseable = gen_optimiseable(locations, errors, seeded_values)
    res = opt.minimize(
        optimiseable,
        (10000, 3, 1.0),
        method="Nelder-Mead", # initial radius, num_min, threshold
        bounds=((0, None), (1, 10), (0.5, 10)),
    )

    print(res)


def main():
    make_charts()
    minimise_cost()


if __name__ == "__main__":
    main()
